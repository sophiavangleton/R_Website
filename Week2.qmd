---
title: "Packages, Data Classes and Indexing"
format: html
description: "Delving into installing and loading packages, data structures, and basics of indexing dataframes"
toc: true
toc-depth: 3
---

Please download this [Week 2 Download](downloadforstudent/week_2_studentversion.qmd) to get the .qmd for this weeks lesson. You will be creating your own project and practice importing this weeks file into your project. (note to self, need to fix link)

## What Is a Package/Library?

Directories are the location of files. Packages/libraries on R are optional set of functions that you can attach to the coding environment. You can think of them as toolkit you can freely download to do complicated and advanced stuff. To use them, you need to first install it. Then, you can load to the current session. Libraries are constantly getting created and updated. Once you pass the basic level, using R(analyzing data) becomes equivalent to "using packages efficiently". So, once you identify your specific issues to solve, always look for packages related to your issue.

**Let's walk through how to install and load a package into your environment:**

**Step 1:** install the package in your console

```{r}
#install.packages("dplyr")
```

The line above downloads the package called dplyr (which we will study together soon!). `install.packages("name of package")` is the syntax. Occasionally, you may want to set `install.packages("whatever",dep=TRUE)`. "dep" stands for dependency, and it forces R to download all "related" packages to the requested one.

You can also download multiple packages at the same time, with the help of a function we learned before: `c()`

```{r}
#install.packages(c("tidyverse", "broom"))
```

**Step 2:** Load your library in your script

To use your packages in a given session, you need to load libraries. You can think about installing a package as 'checking a book out' into your own personal library, and when it comes time for you to 'read' it you will need to pull it off the shelf by loading it into your environment.

```{r}
library(dplyr)
library("dplyr")
```

`library()` should be colored in blue on Rstudio, which indicates this is a special syntax like "for" or "if" or "while". You can provide either character(with "") or just a name.

**Things to be careful when you use packages:** There are few important things to keep in mind when you use libraries.

-   *Make sure that function names are not overlapping.* Each library is often independently developed, so they may contain functions with a same name but different contents. When you load functions with same names from different packages, later ones are prioritized. So, what do we do? To resolve this, you can specify which library is the source of a given function. Say two packages ("packA" and "packB") contain a function called "banana". You can write "packA::banana" to use banana from packA, and vice versa.
-   *Remember that loaded libraries do not disappear even after "rm(list = ls(all = TRUE))".* After you found some form of interference mentioned above, you may want to start over the analysis. To completely start over, you need to shutdown Rstudio because libraries are still loaded even after you clear Environment(workspace)

[Here is a resource](https://support.posit.co/hc/en-us/articles/201057987-Quick-list-of-useful-R-packages) I found online that compiles a list of useful R packages and why they are useful. In general, if you want to do something in R- there is a package for it so always try to look for them first!

**Exercise 1.** Look up the function name `lmer()` using the R help command you learned. What happens? Search the internet and figure out what package the function is from. Install the package and load it.

## Data Types In R

Explanation and examples of functions and data classes/modes in r 

What classes are those vectors? (How do we check the class of an object again?)
```{r}
a <- "123456"
class(a)

b <- c("1", "2", "3")
class(b)

c <- 1:10
class(c)

d <- c(1.1, 2.2, 3.3) + 1
class(d)
```


### Data Structures

R has many types of data structures, called modes. We can find the mode of an object using the `typeof()` function! The most common/important modes are described below.

- **Vector (atomic vector):** a collection of objects of the same class. *Note:* most other programming languages refer to this as an array
- **Matrix:** a vector with two dimensions (rows and columns). These are beyond the scope of this tutorial, but you know that they exist.
```{r}
mymat <- matrix(1:6, nrow = 3, ncol = 2)
dim(mymat)
```

- **Array:** a vector with one or more dimensions. These are beyond the scope of this tutorial, but you know that they exist. *Note:* vectors are 1-dimensional arrays and matrices are 2-dimensional arrays. Arrays with 3 or more dimensions are n-dimensional arrays

```{r}
myarray <- array(1:24, dim = c(3, 4, 2)) # 3x4x2 array: 3 rows, 4 cols, in 2 matrices
```

- **Lists:** are objects that contain all (?) other objects within themselves. They come in handy when you use for loops or other iterative processes, or when you need to save multiple data files per subject. These are beyond the scope of this tutorial, but you know that they exist.

```{r}
subj_01 <- list(eye = 1, 
     resp = "a", 
     beh = 3,
     4)
subj_01
```
- **Data Frame:** a list of possibly heterogeneous elements of equal length (matrix-esque list). Kind of like an Excel spreadsheet in R. DF's contain rows (cases) and columns (variables). It is often easier to manipulate data in this format (vs. list) because there are lots of r functions that have been created to deal specifically with data frames. 

```{r}
People <- c("Ulrich", "Taren", "Dominik", "Sophia", "Neha")
Positions <- c("PI", "GE", "GE", "GE", "GE")
Count <- 1:5
Age <- c(65, 26, 27, 24, 22)

mydf <- data.frame(People, Positions, Count, Age)

#View(mydf)
mydf
```


**Exercise 2.** Extend the dataframe above so a new dataframe contains the names of all RAs present today with their positions (e.g., "RA"), show it in the `View()` window. 

```{r}

```

## What Is Indexing?

(from our glossary) **Indexing** â€” Selecting specific elements from a vector or dataset (e.g., `x[3]`).

When we are handling vectors, indexing becomes incredibly important! With indexing, we can extract values at a specific position of a vector. These positions can be determined by us, but also dependent on certain criteria.

### Indexing using numbers
```{r}
vec <- c(5, 7, 1, 3, 9, 5, 5, 3) #generate vector

fifth_element <- vec[5] #getting the 5th element
vec[2] #2nd element
vec[2:5] #elements 2 through 5
vec[c(3, 5)] #elements 3 and 5
```

**Exercise 3.** How can we get every second element?
- Look up what the function `seq()` does
- Generate a sequence with every second number going from 1 to the last element of the vector
```{r}
vec[seq(from = 1, to = length(vec), by = 2)]
```

Now, we can also change values at certain positions or remove them!

```{r}
vec[5] #get the 5th element
vec[5] <- 2 #change it
vec[5] #check whether change successful

vec <- vec[c(-5, -3)] #here we remove element 5 and 3 from this vector
```


**Exercise 4.** Generate a vector with 7 elements (You can mix strings and numbers!) 
```{r}
vec <- 10:16
#and substitute the 3rd element for the 6th!
vec[3] <- vec[6]
#Please add the number 99 at the end of this vector!
vec[8] <- 99
vec[length(vec) + 1] <- 99
vec <- append(vec, 99)
```


### Indexing using logical values
You can also use logical values to get certain positions in a vector.

```{r}
vec[c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)] #gets me the first element
vec[c(FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)] #gets me the third element
```

Meh, why is this useful? This tool becomes useful when you want to extract values fulfilling certain criteria!

Say you want to extract those values smaller than 5
```{r}
vec[vec < 13] #what happens here?
vec < 5 #this gets me the necessary logical values
```

However, you can get around logical values with `which()`. This function returns the position of those values that match a criterion. 

```{r}
which(vec < 13)
vec[which(vec < 13)]

vec <- c(vec, 99)
```

*Side Note:* some helpful functions with df inspection! We can also get the first and last few items of a vector like this: (*foreshadowing*)
```{r}
head(vec, 2) #getting the first 6 elements
tail(vec, 2) #getting the last 6 elements

tail(mydf, 2)
```

## What is a dataframe?

Dataframe is a type of variable (or a mode of storage) to keep data. It is basically a spreadsheet like format, and this is the most often used mode in R. 
Features of a DF: It looks like a list of possibly heterogeneous elements of equal length (matrix-esque list)
- contains rows (cases) and columns (variables)
- top rows are names of each variable
- each column represents one kind of content
- every column must have the same length (but missing data are allowed)

### Lets generate a dataframe!
```{r}
People <- c('Tess', 'Taren', 'Dominik', "Ulrich") #vector with names
  Positions <- c(rep("GE", 3), "PI") #vector with positions, select from PI, LM (Lab Managaer), GE, and RA
  Count <- 1:length(Positions) #vector with numbers from 1 to N
  
  df <- data.frame(People, Positions, Count)
```

**Exercise 5.** Look up what the function `rep()` does and how it can help us with the Positions vector! Look up the length function and how it could help us avoid hard-coding the Count maximum (here, 14)! Confirm that it is a data.frame (hint: `class(df)`)

```{r}

```

Codes above are altogether making one data.frame variable. First three lines are creating vectors (as you can see in Environment). `mydf()` is a function to create a data.frame, which made independent columns from provided vectors.

### Checking a data.frame
`print()` will display the content of dataframe in the console. 
```{r}
print(df);
df
```


`head()` will do same as `print()` except you can provide number of rows to display
```{r}
head(df)
head(df, 2)
```

`tail()` shows the content from the bottom
```{r}
tail(df)
tail(df, 2)
```

`View()` makes a new tab in the editor window and display the data.frame
```{r}
#View(df)
```

`dim()` gives back the size of data.frame (row by column)
```{r}
dim(df)
ncol(df)
nrow(df)
```

*Note:* that none of these operations will change the content of dataframes. But, it will be important to constantly check your data.frame as it gets updated.

**Let's extract or index variables or specific values.** This is like the room number: The first number(s) is/are the vertical level (rows), the second number(s)/value(s) is/are the rows (room on level). 

Think! `df[level, room]`

**Exercise 6.** Get 4th row, 2nd column. 
```{r}

```

With indexing, there are often multiple ways to achieve the same thing:

You can get 2nd element of column "Position"
```{r}
df$Positions[2] #dollar sign gives us an entire column, which is just a vector and can be indexed as such
df[2, "Positions"] #Here we use column name (has to match exactly) to get the column
df[2, 2] #Here we use the column number to get the second column, which is Position

df[,2] # Get all rows of 2nd column
df$Positions # Get a column "Position"
df[2,]
```

*Note:* When you extract a column from data.frame, it is no longer a data.frame. Do you remember how to check what class of variable it is?

### Adding and removing variables (columns)
```{r}
# Direct
df$RowNum <- rep(1, nrow(df))

#indirect
RowNum <- rep(1, nrow(df))
df$RowNum <- RowNum

#Remove
df$RowNum <- NULL
```

*Note:* To add a variable or new column, you can directly feed in information or use a variable. Direct way is slightly more efficient as it leaves no trace in the Environment.

### Filtering rows by conditioning

Filtering is an operation to keep or remove certain rows. We can filter rows corresponding to RAs

```{r}
df[Positions == "RA",]

df[df$Positions == "PI",]

df_only_PI<- df[Positions == "PI",]

# Filter rows corresponding to RAs or PI
df[Positions == "GE" & Count == 2,]
```
